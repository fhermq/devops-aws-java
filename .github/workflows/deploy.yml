name: Build and Deploy Microservice

on:
  push:
    branches:
      - develop
      - stage
      - main
    tags:
      - 'v*'
    paths-ignore:
      - 'terraform/**'
      - '.github/workflows/terraform.yml'
  pull_request:
    branches:
      - develop
      - stage
      - main
    paths-ignore:
      - 'terraform/**'
      - '.github/workflows/terraform.yml'
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_REPOSITORY: devops-aws-java
  JAVA_VERSION: '21'

jobs:
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Run Maven build and tests
        run: mvn clean package -B

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: target/surefire-reports/

  build-and-push-image:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: build-and-test
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/stage' || github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v'))
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image tags
        id: image-tags
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            TAG=${GITHUB_REF#refs/tags/}
            ENVIRONMENT="production"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAG="latest"
            ENVIRONMENT="production"
          elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
            TAG="stage-${GITHUB_SHA::7}"
            ENVIRONMENT="staging"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            TAG="develop-${GITHUB_SHA::7}"
            ENVIRONMENT="development"
          fi
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "Image tag: ${TAG} (${ENVIRONMENT})"

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: |
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tags.outputs.tag }}
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest
          outputs: type=docker,dest=/tmp/image.tar

      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar
          retention-days: 1

      - name: Set environment output
        run: echo "ENVIRONMENT=${{ steps.image-tags.outputs.environment }}" >> $GITHUB_ENV

  push-to-ecr:
    name: Push to ECR
    runs-on: ubuntu-latest
    needs: build-and-push-image
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/stage' || github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v'))
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate image tag
        id: image-tag
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            TAG=${GITHUB_REF#refs/tags/}
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAG="latest"
          elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
            TAG="stage-${GITHUB_SHA::7}"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            TAG="develop-${GITHUB_SHA::7}"
          fi
          echo "tag=${TAG}" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/github-actions-ecr-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify OIDC role assumption
        run: |
          echo "Checking assumed role..."
          IDENTITY=$(aws sts get-caller-identity)
          echo "$IDENTITY"
          ROLE=$(echo "$IDENTITY" | jq -r '.Arn')
          if [[ "$ROLE" == *"github-actions-ecr-role"* ]]; then
            echo "✓ Successfully assumed github-actions-ecr-role"
          else
            echo "✗ Not using github-actions-ecr-role, using: $ROLE"
            exit 1
          fi

      - name: Verify AWS credentials
        run: |
          echo "Verifying AWS credentials..."
          aws sts get-caller-identity
          echo "Testing ECR authorization..."
          aws ecr get-authorization-token --region ${{ env.AWS_REGION }} || echo "ECR auth failed"

      - name: Login to Amazon ECR
        run: |
          echo "Getting ECR login password..."
          PASSWORD=$(aws ecr get-login-password --region ${{ env.AWS_REGION }} 2>&1)
          if [ $? -ne 0 ]; then
            echo "Failed to get ECR password: $PASSWORD"
            exit 1
          fi
          echo "Logging in to Docker..."
          echo "$PASSWORD" | docker login --username AWS --password-stdin ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          if [ $? -ne 0 ]; then
            echo "Docker login failed"
            exit 1
          fi
          echo "Docker login successful"

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load and push Docker image
        run: |
          docker load --input /tmp/image.tar
          
          # Re-authenticate before pushing (in case token expired)
          echo "Re-authenticating with ECR..."
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          echo "Pushing image with tag: ${{ steps.image-tag.outputs.tag }}"
          docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.tag }}
          
          echo "Pushing image with tag: latest"
          docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest

      - name: Image scan results
        run: |
          echo "✓ Image pushed to ECR"
          echo "Registry: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          echo "Repository: ${{ env.ECR_REPOSITORY }}"
          echo "Tag: ${{ steps.image-tag.outputs.tag }}"
          echo "Branch: ${{ github.ref }}"

  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: push-to-ecr
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/stage' || github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v'))
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate image tag
        id: image-tag
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            TAG=${GITHUB_REF#refs/tags/}
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAG="latest"
          elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
            TAG="stage-${GITHUB_SHA::7}"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            TAG="develop-${GITHUB_SHA::7}"
          fi
          echo "tag=${TAG}" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/github-actions-ecr-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Pull and run Docker image
        run: |
          docker pull ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.tag }}
          docker run -d -p 8080:8080 --name microservice-test \
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.tag }}
          sleep 5

      - name: Test health endpoint
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health)
          if [ "$response" != "200" ]; then
            echo "Health check failed with status: $response"
            exit 1
          fi
          echo "✓ Health endpoint OK"

      - name: Test ready endpoint
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ready)
          if [ "$response" != "200" ]; then
            echo "Ready check failed with status: $response"
            exit 1
          fi
          echo "✓ Ready endpoint OK"

      - name: Test API endpoint
        run: |
          response=$(curl -s http://localhost:8080/api/hello)
          if [[ ! "$response" =~ "Hello" ]]; then
            echo "API test failed: $response"
            exit 1
          fi
          echo "✓ API endpoint OK: $response"

      - name: Test metrics endpoint
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/actuator/prometheus)
          if [ "$response" != "200" ]; then
            echo "Metrics check failed with status: $response"
            exit 1
          fi
          echo "✓ Metrics endpoint OK"

      - name: Cleanup
        if: always()
        run: docker stop microservice-test || true

      - name: Smoke tests summary
        run: |
          echo "✓ All smoke tests passed!"
          echo "Branch: ${{ github.ref }}"
          echo "Image: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.tag }}"

  deploy-to-kubernetes:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: smoke-tests
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/github-actions-ecr-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name devops-aws-java-cluster

      - name: Install AWS Load Balancer Controller
        run: |
          echo "Checking if AWS Load Balancer Controller is already installed..."
          if kubectl get deployment -n kube-system aws-load-balancer-controller &>/dev/null; then
            echo "✓ AWS Load Balancer Controller already installed"
          else
            echo "Installing AWS Load Balancer Controller..."
            
            # Get the Load Balancer Controller role ARN from Terraform outputs
            ROLE_ARN=$(aws iam list-roles --query "Roles[?RoleName=='devops-aws-java-cluster-load-balancer-controller-role'].Arn" --output text)
            
            if [ -z "$ROLE_ARN" ]; then
              echo "✗ Load Balancer Controller role not found"
              exit 1
            fi
            
            echo "Using role: $ROLE_ARN"
            
            # Deploy AWS Load Balancer Controller via Helm
            helm upgrade --install aws-load-balancer-controller helm/aws-load-balancer-controller \
              --namespace kube-system \
              --set serviceAccount.annotations."eks\.amazonaws\.com/role-arn"="$ROLE_ARN" \
              --timeout 5m
            
            echo "Waiting for AWS Load Balancer Controller to be ready..."
            kubectl rollout status deployment/aws-load-balancer-controller -n kube-system --timeout=5m
            echo "✓ AWS Load Balancer Controller installed successfully"
          fi

      - name: Deploy with Helm
        run: |
          echo "Creating ECR image pull secret..."
          kubectl create secret docker-registry ecr-secret \
            --docker-server=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com \
            --docker-username=AWS \
            --docker-password=$(aws ecr get-login-password --region ${{ env.AWS_REGION }}) \
            --namespace=default \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "Deploying microservice with Helm..."
          helm upgrade --install microservice helm/microservice \
            -f helm/microservice/values-prod.yaml \
            --set image.registry=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com \
            --set imagePullSecrets[0].name=ecr-secret \
            --timeout 15m
          
          echo "Waiting for deployment to be ready..."
          kubectl rollout status deployment/microservice --timeout=10m || true
          
          echo "Helm deployment completed"

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/microservice --timeout=5m
          kubectl get pods -l app.kubernetes.io/name=microservice

      - name: Wait for LoadBalancer to be provisioned
        run: |
          echo "Waiting for LoadBalancer to be provisioned..."
          for i in {1..60}; do
            LB_DNS=$(kubectl get svc microservice -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
            if [ ! -z "$LB_DNS" ]; then
              echo "✓ LoadBalancer provisioned: $LB_DNS"
              echo "LB_DNS=$LB_DNS" >> $GITHUB_ENV
              break
            fi
            echo "Waiting... ($i/60)"
            sleep 5
          done
          
          if [ -z "$LB_DNS" ]; then
            echo "⚠ LoadBalancer not yet provisioned, checking NLB status..."
            aws elbv2 describe-load-balancers --region ${{ env.AWS_REGION }} --query 'LoadBalancers[*].[LoadBalancerName,DNSName,State.Code]' --output table
          fi

      - name: Get LoadBalancer URL
        run: |
          echo "LoadBalancer URL:"
          if [ ! -z "$LB_DNS" ]; then
            echo "$LB_DNS"
          else
            echo "Checking via AWS CLI..."
            aws elbv2 describe-load-balancers --region ${{ env.AWS_REGION }} --query 'LoadBalancers[*].DNSName' --output text
          fi

      - name: Deployment summary
        run: |
          echo "✓ Deployment to production complete!"
          echo "Branch: main"
          echo "Cluster: devops-aws-java-cluster"
          echo "Namespace: default"
          if [ ! -z "$LB_DNS" ]; then
            echo "LoadBalancer: $LB_DNS"
          fi
